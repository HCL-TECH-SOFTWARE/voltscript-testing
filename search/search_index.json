{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to VoltScript Testing documentation","text":"<p>VoltScript Testing is a framework for testing code written using VoltScript, the evolution of LotusScript, delivered as part of HCL Volt MX Go. The framework can be used for LotusScript with modifications.</p> <p>There are no dependencies on any LotusScript Extensions (LSX), such as <code>nlsxbe.dll</code>. None should be added. It makes it dependent on a particular implementation.</p>"},{"location":"index.html#whats-new","title":"What's new","text":"<p>For the latest release information about VoltScript Testing, see What's new.</p>"},{"location":"index.html#using-via-dependency-management","title":"Using via dependency management","text":"<p>For using with dependency management, see Use dependency management.</p>"},{"location":"index.html#how-the-documentation-is-organized","title":"How the documentation is organized","text":"<p>The documentation is based on the Di\u00e1taxis framework, which organizes documentation into the following modes to address users' documentation needs at different times and in different circumstances. Below shows an overview that guides you on where to look for needed information:</p> <p>Tutorials - Hands-on introduction on how to use VoltScript Testing</p> <p>How-to guides - Practical step-by-step guides for performing tasks and operation</p> <p>Topic guides - High-level discussion and explanation of key topics and concepts in VoltScript Testing</p> <p>References - Contain API documentation and test reports</p>"},{"location":"howto/index.html","title":"How-to guides","text":"<p>How-to guides instruct users in completing key goals and tasks related to VoltScript Testing.</p> <ul> <li>Use dependency management</li> <li>Write a standalone test suite</li> <li>Aggregate test suites</li> <li>Write tests</li> <li>Mock calls</li> <li>Integrate with CI/CD</li> <li>Write code to BeforeAll, BeforeEach</li> <li>Write a custom tester</li> <li>Use VoltScript Testing for validation</li> <li>Change functions to be testable</li> <li>Know where to write your tests</li> </ul>"},{"location":"howto/BeforeAfterTester.html","title":"Write code to BeforeAll, BeforeEach etc","text":"<p>The full code can be found in SampleBeforeAfterTester.</p>"},{"location":"howto/BeforeAfterTester.html#beforeafter-code","title":"BeforeAfter Code","text":"<pre><code>Class IntegerIncrementBeforeAfter As AbstractCustomBeforeAfter\n\n    Sub beforeAll()\n        a = 0\n        b = 0\n    End Sub\n\n    Sub beforeEach()\n        a++\n    End Sub\n\n    Sub afterEach()\n        b++\n    End Sub\n\n    Sub afterAll()\n        Print |a is | &amp; a &amp; |, b is | &amp; b\n    End Sub\n\nEnd Class\n</code></pre> <p>This CustomBeforeAfterTester uses all four methods. The variables <code>a</code> and <code>b</code> are not declared in the class, because they are needed in the actual tests. As a result, they are declared as global private variables.</p> <p>The <code>beforeAll()</code> method starting at line 3 is only for explicit instantiation of the integers. If not explicitly set, they will be 0 anyway.</p> <p>In the <code>beforeEach()</code> method starting at line 8 we increment <code>a</code>. In the <code>afterEach()</code> method starting at line 12 we increment <code>b</code>.</p> <p>Finally, we use the <code>afterAll</code> to print out <code>a</code> and <code>b</code>.</p>"},{"location":"howto/BeforeAfterTester.html#test-code","title":"Test Code","text":"<pre><code>Dim testSuite As New TestSuite(|Custom BeforeAfter Tester|)\nDim beforeAfter As New IntegerIncrementBeforeAfter\n\nCall testSuite.addCustomBeforeAfter(beforeAfter)\n\n'a = 1, b = 0\ntestSuite.describe(|Test b is false|).assertFalse(b)\n\n'a = 2, b = 1\nCall testSuite.describe(|Test a equals 2|).assertEqualsInteger(2, a)\n\n'a = 3, b = 2\nCall testSuite.describe(|Test b equals 2 primitive|).assertEqualsPrimitive(2, b)\n\n'a = 4, b = 3\nDim f As Double\nf = 3.0\nCall testSuite.describe(|Test CDbl(b) = 3.0|).assertEqualsDouble(f, CDbl(b))\n\n'a = 5, b = 4\nDim c As Single\nc = 4\nCall testSuite.describe(|Test CSngl(b) = 4|).assertEqualsSingle(c, CSng(b))\n\n'a = 6, b = 5\nDim d As Long\nd = 5\nCall testSuite.describe(|Test CLng(b) = 5|).assertEqualsLong(d, CLng(b))\n\n'a = 7, b = 6\nDim e As Integer\ne = b + 1\nCall testSuite.describe(|Test a numeric = b + 1|).assertEqualsNumeric(e, a)\n</code></pre> <p>In line 1 we just create a TestSuite without a TestRunner, because we are only running a single test suite. In line 2 we create a instance of the custom BeforeAfter class, and in line 4 we add it to the test suite. Now we are ready to start running tests. Many of the tests are straightforward, but some deserve further comment.</p> <p>On lines 16 and 17 we create a double to pass to the <code>assertEqualsDouble()</code>. This is because we cannot just pass <code>3.0</code>. We could use <code>assertEqualsNumeric()</code>, which proxies off to <code>assertEqualsDouble()</code>, but on this occasion we're using the lower level assertion.</p> <p>Note on line 18 we compare <code>b</code>. If we were to test <code>a</code>, we would need to expect the value to be 3, not 4. This is because, although the <code>CDbl()</code> function is inside the assertion, it is executed before the assertion - and thus before the <code>beforeEach()</code> is triggered. The result of the executation passed to the assertion, at which point the <code>beforeEach()</code> will run. As a result, for ease of fourth-dimensional thinking, we just compare against the value modified in the <code>afterEach()</code> function.</p>"},{"location":"howto/Jenkins.html","title":"Integrate with CI/CD","text":"<p>If the test is set to output an XML file, this can be automatically picked up by your CI/CD environment, e.g. Jenkins. This needs to be set on the highest level of the hierarchy, changing the output format.</p> <p>If you are using a TestRunner, call <code>TestRunner.setOutputFormat()</code>. Otherwise, call <code>TestSuite.setOutputFormat()</code>. TestSuites assigned to a TestRunner take the same output format as the TestRunner.</p> <p>To just output an XML file, call <code>setOutputFormat(\"XML\")</code>. To output the HTML files and XML files, call <code>setOutputFormat(\"BOTH\")</code>.</p> <p>For a TestRunner, a single XML file is created that contains the XML for the TestRunner and all TestSuites allocated to it.</p> <p>If a test suite fails, ensure an error is bubbled up to the runtime, with sufficient information to identify which test or tests failed. This ensures the VoltScript Runtime process exits with an error, which notifies CI/CD that that the build should be aborted.</p>"},{"location":"howto/Standalone.html","title":"Write a standalone test suite","text":"<p>SimpleBeforeAfterTester uses this approach.</p> <ol> <li>Add <code>Use \"TestSuite\"</code> to create a set of tests.</li> <li> <p>Instantiate the TestSuite object, passing a name for the tests. </p> <p>This will be combined with the run-time timestamp for the filename of the HTML file, in format \"MyTests-20220331T123000.html\". Spaces will be removed, but no other modifications to the title. It's the developer's responsibility to ensure no invalid characters. The output location can be overridden using the <code>outputTo()</code> function.</p> </li> </ol>"},{"location":"howto/TestRunner.html","title":"Aggregate test suites","text":"<p>There are two hierarchies:</p> <ul> <li>TestRunner for aggregating multiple test suites. The default output format is HTML. This will output multiple HTML files, one for each test suite, with an index.html to bootstrap them.</li> <li>TestSuite for creating a single test suite containing multiple tests.</li> </ul>"},{"location":"howto/TestRunner.html#testrunner","title":"TestRunner","text":"<p>Simple Example uses this approach.</p> <ol> <li>Add <code>Use \"VoltScriptTesting\"</code> to incorporate the VoltScript Testing script.</li> <li> <p>Declare a <code>New TestRunner</code> to aggregate all test suites, passing a label. </p> <p>This will be combined with the run-time timestamp for the directory name containing the HTML files, in format \"MyTitle-20220331T123000\". Spaces will be removed, but no other modifications to the title. It's the developer's responsibility to ensure no invalid characters. The best practice is to use only alphanumeric characters. The files will be placed in the sub-directory <code>unit-test-reports</code> under the run context. The output location can be overridden using the <code>outputTo()</code> function. Changing this at the TestRunner will filter down to all TestSuites added to the TestRunner.</p> <p>Tip</p> <p>For best clarity, a separate function is used for each test suite, with the test runner passed as an argument to each function.</p> </li> <li> <p>Instantiate a TestSuite object, passing a name for the tests. </p> <p>This will be used for the filename of the HTML file, in format <code>MyTests.html</code>. The file will be in the same directory as the <code>index.html</code>. Spaces will be removed, but no other modifications to the title. It's the developer's responsibility to ensure no invalid characters. The best practice is to use only alphanumeric characters.</p> </li> <li> <p>Add the TestSuite object to the TestRunner object, using <code>MyTestRunner.addTestSuite(MyTestSuite)</code>. </p> <p>As an alternative, there is a <code>TestRunner.createTestSuite(\"Test Title\")</code> method, which returns a newly created TestSuite object.</p> </li> </ol>"},{"location":"howto/archipelago.html","title":"Use dependency management","text":"<p>Info</p> <p>For generic how-to information about VoltScript Dependency Management, see VoltScript documentation.</p> <p>Dependency management is available in the documentation for each project, but also aggregated here:</p>"},{"location":"howto/archipelago.html#authentication","title":"Authentication","text":"<p>You'll need a Personal Access Token to use GitHub REST APIs. You'll then need to add the following to the JSON object in your atlas-settings.json in the <code>.vss</code> directory of your user home directory:</p> <pre><code>    \"hcl-github\": {\n        \"type\": \"github\",\n        \"token\": \"${env.TOKEN}\"\n    }\n</code></pre>"},{"location":"howto/archipelago.html#repository","title":"Repository","text":"<p>You'll need to add the following to your repositories object in the <code>atlas.json</code> of your project:</p> <pre><code>        {\n            \"id\": \"hcl-github\",\n            \"type\": \"github\",\n            \"url\": \"https://api.github.com/repos/HCL-TECH-SOFTWARE\"\n        }\n</code></pre>"},{"location":"howto/archipelago.html#dependency","title":"Dependency","text":"<p>You'll need to add the following relevant dependency to your dependencies or testDependencies object in the <code>atlas.json</code> of your project:</p> <pre><code>        {\n            \"library\": \"voltscript-testing\",\n            \"version\": \"1.0.1\",\n            \"module\": \"VoltScriptTesting.vss\",\n            \"repository\": \"hcl-github\"\n        }\n</code></pre>"},{"location":"howto/customtester.html","title":"Write a custom tester","text":""},{"location":"howto/customtester.html#custom-class","title":"Custom Class","text":"<p>A custom tester can be used to run multiuple tests. The custom tester is a Class that extends <code>AbstractCustomTester</code>. It needs a <code>runTests()</code> function that returns a boolean.</p> <pre><code>Private Class DateTimeTester As AbstractCustomTester\n\n    Function runTests As Boolean\n\n        Dim dateTime As Variant\n        Dim mon As Integer\n\n        Call Me.testSuite.checkStarted()\n\n        dateTime = CDat(|30/01/2022|)\n        Call checkIsDateTime(Datetime)\n\n        mon = Month(dateTime)\n        checkMonthLessThan13(mon)\n\n        Call Me.testSuite.describe(|Check dateTime is before Now|).assertIsLessThan(Now(), CDbl(dateTime))\n\n    End Function\n\nEnd Class\n</code></pre> <p>This is a custom class extending <code>AbstractCustomTester</code>. The only function we need to add is <code>runTests()</code>. The function can return a boolean if successful. But here, the outer code is only interested in whether or not the TestSuite ran successfully, which the TestSuite class handles internally. So no return value is passed out of the function.</p> <p>This is the first test for the TestSuite, so on line 8, we call the <code>checkStarted</code> function of the TestSuite, which is a property of the parent class. This sets the timer for the TestSuite and, if appropriate, runs a custom <code>beforeAll()</code> function. We then call two internal functions - <code>checkIsDateTime()</code> and <code>checkMonthLessThan13()</code> and finally run an inline assertion. These are:</p> <pre><code>Function checkIsDateTime(dateTime As Variant) As Boolean\n    checkIsDateTime = Me.testSuite.describe(|Check is DateTime Variant|).assertIs(|DATE|, dateTime)\nEnd Function\n\nFunction checkMonthLessThan13(mon As Integer)\n\n    Try\n        Call Me.testSuite.describe(|Check month is less than 13|)\n        If (mon &lt; 13) Then\n            Call Me.testSuite.addResult(True, \"\")\n            checkMonthLessThan13 = True\n        Else\n            Call Me.testSuite.addResult(False, \"Expected less than 13, was \" &amp; mon)\n            checkMonthLessThan13 = False\n        End If\n    Catch\n        Call testSuite.addError(testSuite.getErrorMsg, GetThreadInfo(12))\n    End Try\n\nEnd Function\n</code></pre> <p>The first function runs a simple assertion. The second one is more complex. A result is added (true or false), with the appropriate message. If there is an error - which should not happen in this scenario - the test is errored.</p>"},{"location":"howto/customtester.html#using-the-class","title":"Using the Class","text":"<p>Using the class is very straightforward. We create a TestSuite and an instance of the custom tester class. We then add the TestSuite to the tester and call the tester's <code>runTests()</code> function.</p> <pre><code>Dim TestSuite As New TestSuite(|DateTime Tests|)\nDim DateTimeTester As New DateTimeTester\n\nCall DateTimeTester.addTestSuite(TestSuite).runTests()\n</code></pre> <p>If we wished, additional tests could be run before or after calling the tester's <code>runTests()</code> function.</p>"},{"location":"howto/location.html","title":"Know where to write your tests","text":"<p>Test suites are best written as functions in the same script as the functions they're testing. Typically, they're located at the end of the script for clearer separation. Including the functions in the same script they're testing allows use of private variables, such as to mock actual objects, route logic differently, and write errors elsewhere.</p> <p>You can use a separate unit test / integration script to trigger the test functions. This typically handles errors internally to make sure all test suites are run. If a test suite fails, an error is bubbled up to the runtime with enough information to identify which test or tests failed. When running tests from CI/CD, it ensures the VoltScript Runtime process exits with an error, which notifies CI/CD that that the build should be aborted.</p>"},{"location":"howto/mocking.html","title":"Mock calls","text":"<p>Unlike other frameworks, the language engine does not permit bypassing API calls during testing. As a result, code may need to be restructured to be testable. This is not completely unique to VoltScript. In other languages there are also cases where it is better to refactor code to be more testable.</p>"},{"location":"howto/mocking.html#forcing-an-error","title":"Forcing an Error","text":"<p>Proper testing not only tests successful outcomes but also errors. Sometimes this can be done by passing invalid content into a function.</p> <pre><code>Function convertStringToInteger(passedVal as String) as Integer\n\n    CInt(passedVal)\n\nEnd Function\n</code></pre> <p>This can be tested by passing a non-numeric value.</p> <p>Other times, it is less simple and errors may only occur because of invalid environmental causes. This can be mocked by setting a boolean variable, and checking for the existence of this variable in your code.</p> <pre><code>Dim FORCE_ERRORS as Boolean\n\nFunction doComplexProcessing()\n\n    If FORCE_ERRORS Then Error 1001, \"Invalid Content\"\n    ...\n\nEnd Function\n</code></pre> <p>This scenario envisages that there is a lot of additionl content for the <code>doComplexProcessing()</code> function, which uses a lot of variables set elsewhere and refactoring the code is not desirable. Setting up all those other variables is difficult in unit testing and will be covered by integration testing. But testing the error is simple, the tester can set <code>FORCE_ERRORS</code> to true and expect an error.</p> <p>Note</p> <p>Remember to reset FORCE_ERRORS afterwards.</p>"},{"location":"howto/mocking.html#creating-mock-data-inline","title":"Creating Mock Data Inline","text":"<p>An alternative approach would be to use a <code>TEST_RUN</code> boolean variable and check for it. Code can then run <code>If TEST_RUN Then Call createMockDoc()</code>, running a function to create mock data inline. Tests can set that <code>TEST_RUN</code> variable at the start of processing.</p>"},{"location":"howto/untestable-to-testable.html","title":"Change functions to be testable","text":"<p>Functions may need to be changed or written differently. It's easy to convert an example on a blog post about writing testable code for VoltScript. Imagine the following function:</p> <pre><code>Function getTimeOfDay() as String\n\n    Dim nowTime as Variant\n    nowTime = Now()\n    If (Hour(Now) &lt; 8) Then\n        getTimeOfDay = \"Night\"\n    ElseIf (Hour(Now) &lt; 12) Then\n        getTimeOfDay = \"Morning\"\n    ElseIf (Hour(Now) &lt; 6) Then\n        getTimeOfDay = \"Afternoon\"\n    Else\n        getTimeOfDay = \"Night\"\n    End If\n\nEnd Function\n</code></pre> <p>This function is untestable, unless you are willing to test at multiple times of day or change the system time. Rewriting the function slightly can make it eminently testable:</p> <pre><code>Function getTimeOfDay(nowTime as Variant) as String\n\n    If (Hour(Now) &lt; 8) Then\n        getTimeOfDay = \"Night\"\n    ElseIf (Hour(Now) &lt; 12) Then\n        getTimeOfDay = \"Morning\"\n    ElseIf (Hour(Now) &lt; 6) Then\n        getTimeOfDay = \"Afternoon\"\n    Else\n        getTimeOfDay = \"Night\"\n    End If\n\nEnd Function\n</code></pre> <p>Now it can be tested easily:</p> <pre><code>Dim testSuite as New TestSuite(\"Testing time of day\")\nDim nowTime as Variant\nnowTime = TimeNumber(4,30,04)  ' Fine because we're only interested in the time\nCall testSuite.describe(\"Test Night am\").assertEqualsString(\"Night\", getTimeOfDay(nowTime), True)\nnowTime = TimeNumber(8,30,04)\nCall testSuite.describe(\"Test Morning\").assertEqualsString(\"Morning\", getTimeOfDay(nowTime), True)\nnowTime = TimeNumber(13,30,04)\nCall testSuite.describe(\"Test Afternoon\").assertEqualsString(\"Afternoon\", getTimeOfDay(nowTime), True)\nnowTime = TimeNumber(20,30,04)\nCall testSuite.describe(\"Test Night pm\").assertEqualsString(\"Night\", getTimeOfDay(nowTime), True)\n</code></pre>"},{"location":"howto/validation.html","title":"Use VoltScript Testing for validation","text":"<p>Imagine we have the following class:</p> <pre><code>Class Person\n    Public firstName as String\n    Public lastName as String\n    Public age as Integer\n\n    Sub New()\n\n    End Sub\nEnd Class\n</code></pre> <p>We may want to validate that a Person has been set up correctly, because properties are not set and validated during the constructor.</p>"},{"location":"howto/validation.html#set-up-person","title":"Set up Person","text":"<pre><code>Dim person as New Person()\nperson.firstName = \"John\"\nperson.lastName = \"Doe\"\nperson.age = 42\n</code></pre> <p>We will create the Person and set property values, ready for validation. In reality, this might be a JSON object received or a VoltScript object pre-populated outside the script that wants to validate it.</p>"},{"location":"howto/validation.html#test-code","title":"Test code","text":"<pre><code>Dim testSuite as New TestSuite(\"Validator\")\ntestSuite.suppressReport = True\nCall testSuite.describe(\"fname\").assertNotEqualString(\"\", person.firstName)\nCall testSuite.describe(\"lname\").assertNotEqualString(\"\", person.lastName)\nCall testSuite.describe(\"age &gt; 0\").assertIsGreaterThan(0.0, CDbl(person.age))\nCall testSuite.describe(\"age &gt; 0 alt\").assertTrue(person.age &gt; 0)\nCall testSuite.describe(\"age sensible\").assertTrue(person.age &lt; 110)\n</code></pre> <p>We need to pass a name to the TestSuite in line 1, even though it's not being used. The key is line 2, where we suppress the report. If we did not, when the code finishes and the TestSuite is deleted, the HTML reports would be generated - unnecessarily.</p> <p>In lines 3 - 8 we run the tests. Age is an integer, so could potentially be a negative integer, or much bigger than the age a person could be.</p>"},{"location":"howto/validation.html#check-the-validation-run","title":"Check the validation run","text":"<pre><code>If testSuite.ranSuccessfully() Then\n    Print \"Person valid\"\nElse\n    errMsg = \"Person not valid\"\n    ForAll test in testSuite.results\n      If (test.outcome &lt;&gt; \"Passed\") Then\n        errMsg = errMsg &amp; Chr(10) &amp; ListTag(test) &amp; \": \" &amp; test.errorMsg\n      End If\n    End ForAll\n    Error 1001, errMsg\nEnd If\n</code></pre> <p>Checking validation worked is straightforward and done by calling the <code>ranSuccessfully()</code> function in line 1. If it wasn't successful, you want to identify what went wrong. This is done in lines 5 - 9. We loop through the results, which gives us access to the TestCase object. If the outcome was not \"Passed\", we capture the reason - the TestCase's errorMsg. This would be something like \"Expected: 1, but was: 3\".</p>"},{"location":"howto/writingtests.html","title":"Write tests","text":""},{"location":"howto/writingtests.html#creating-a-test","title":"Creating a Test","text":"<p>Each test needs a description. This is set by calling <code>Call TestSuite.describe(|My Test Name|)</code>. If this is omitted, the test name is \"Test \" + a unique number. Tests must be followed by an assertion. If this is accidentally forgotten, the test will fail with a \"Missing Assertion\" response.</p> <p>The <code>describe()</code> function returns the TestSuite, so the assertion can be chained onto the end of the <code>describe</code> call, e.g. <code>Call TestSuite.describe(|My Test Name|).assertTrue(True)</code>. This is recommended for better readability.</p>"},{"location":"howto/writingtests.html#assertions","title":"Assertions","text":""},{"location":"howto/writingtests.html#in-built-assertions","title":"In-Built Assertions","text":"<p>All assertion functions begin <code>assert...</code>. The in-built assertions are:</p> <ul> <li><code>assertTrue(actual as Boolean)</code> expects the expression or variable passed in is true or numeric not 0.</li> <li><code>assertFalse(actual as Boolean)</code> expects the expression or variable passed in is false or numeric 0.</li> <li><code>assertIs(expectedType as String, actual as Variant)</code> runs <code>TypeName()</code> on the actual value passed and compares its type to the expected type. For objects, this is the actual class name. For objects that are derived classes cannot be used to check if the object is an instance of a base class. For example, if you create your own custom tester class, you cannot use this to check if it is an instance of AbstractCustomTester. For best practice, pass the class name as upper case. However, internally, the code will <code>LCase()</code> both.</li> <li><code>assertIsNot(expectedType as String, actual as Variant)</code> runs the opposite test.</li> <li><code>assertEqualsString(expected as String, actual as String, caseInsensitive as Boolean)</code> expects the two strings to match. The third parameter can be used to force case-sensitive comparison. If <code>false</code> the two values are compared as lower case. This method is only intended for simple string comparisons. If pitch comparison is required, use <code>StrCompare</code> with the appropriate in-built assertion or a custom assertion function / custom tester.</li> <li><code>assertNotEqualString(expected as String, actual as String, caseInsensitive as Boolean)</code> runs the opposite test.</li> <li><code>assertEqualsDouble(expected as Double, actual as Double)</code> expects two doubles to match, running <code>CStr()</code> to avoid bit-level issues.</li> <li><code>assertNotEqualDouble(expected as Double, actual as Double)</code> runs the opposite test.</li> <li><code>assertEqualsInteger(expected as Integer, actual as Integer)</code> expects two integer to match.</li> <li><code>assertNotEqualInteger(expected as Integer, actual as Integer)</code> runs the opposite test.</li> <li><code>assertEqualsLong(expected as Long, actual as Long)</code> expects two longs to match, running <code>CStr()</code> to avoid bit-level issues.</li> <li><code>assertNotEqualLong(expected as Long, actual as Long)</code> runs the opposite test.</li> <li><code>assertEqualsSingle(expected as Single, actual as Single)</code> expects two singles to match, running <code>CStr()</code> to avoid bit-level issues.</li> <li><code>assertNotEqualSingle(expected as Single, actual as Single)</code> runs the opposite test.</li> <li><code>assertEqualsNumeric(expected as Variant, actual as Variant)</code> expects two numeric values to match, running <code>CStr()</code> to avoid bit-level issues.</li> <li><code>assertNotEqualNumeric(expected as Variant, actual as Variant)</code> runs the opposite test.</li> <li><code>assertIsBetween(expected1 as Double, expected2 as Double, actual as Double)</code> expects the actual to be greater than or equal to the first expected value and less than or equal to the second. This runs \"between\", not \"strictly between\". If you want to run a \"strictly between\" test, use <code>assertTrue()</code> or <code>assertFalse()</code> withg an expression, or a custom tester.</li> <li><code>assertIsGreaterThan(expected as Double, actual as Double)</code> expects the actual to be greater than the expected value.</li> <li><code>assertIsLessThan(expected as Double, actual as Double)</code> expects the actual to be less than the expected value.</li> <li><code>assertEqualsPrimitive(expected as Variant, actual as Variant)</code> expects the two variables to match, ignoring data type and CStr-ing the values. So \"1\" and 1 will be considered equal, but \"One\" and \"one\" will not.</li> <li><code>assertEqualsPrimitiveOrPrimitiveArray(expected as Variant, actual as Variant)</code> expects the two variables to match, running <code>assertEqualsPrimitive()</code> on each variable or array element. If one is an array and the other is not, the assertion will fail. If both are arrays, each element will be compared with the element at the same index.</li> </ul> <p>All in-built assertions have error handling in-built and will give a full stack trace for VoltScript. Each assertion returns a true / false for success, which can be utilised, if required.</p> <p>For more details of classes etc in use, see API Documentation.</p>"},{"location":"howto/writingtests.html#custom-assertions","title":"Custom Assertions","text":"<p>If an assertion is required beyond the basic options, this can be achieved by performing a function on the appropriate variables and passing the result of the function to an <code>assertTrue()</code> or <code>assertFalse()</code>.</p> <p>In simple cases this can be done inline. When doing so, be aware that an error in the function call (e.g. <code>CDbl</code> on a non-numeric value) will abort processing before the assertion is run. If more processing is required than can be done in a single function call, conditional processing can be used.</p> <pre><code>Dim dateVal as Variant\nTry\n    Call testSuite.describe(|Check month is less than 13|)\n    dateVal = CDat(passedVal)\n    If (Month(dateVal) &lt; 13) Then\n        If (Day(dateVal) &lt; 32) Then\n            If (Year(dateVal) &gt; 1900 And Year(dateVal) &lt; 2000)\n                Call testSuite.addResult(True, \"\")\n            Else\n                Call testSuite.addResult(False, \"Expected between 1900 and 2000, was \" &amp; Year(dateVal))\n        Else\n            Call testSuite.addResult(False, \"Expected less than 31, was \" &amp; Day(dateVal))\n        End If\n    Else\n        Call testSuite.addResult(False, \"Expected less than 13, was \" &amp; Month(dateVal))\n    End If\nCatch\n    Call testSuite.addError(Error() &amp; \" on \" &amp; Erl(), GetThreadInfo(12))\nEnd Try\n</code></pre> <p>This code expects a date string to be passed (<code>passedVal</code>, used in line 4). Rather than running multiple assertions checking various aspects of the date, it runs various conditional statements, failing the test if any part fails, succeeding if all conditionals are true, and adding an error on line 18 if the date conversion fails.</p> <p>In other scenarios, a custom function that returns a boolean may be more appropriate, with an assertion on the result.</p> <p>In very complex cases, a custom tester class can be used.</p> <p>If you have custom before/after code for tests, remember to call <code>TestSuite.runBeforeEach()</code> before running your test and <code>TestSuite.runAfterEach()</code> at the end.</p>"},{"location":"howto/writingtests.html#custom-assertions-as-first-test","title":"Custom Assertions as First Test","text":"<p>In-built assertions will always call <code>checkStarted()</code> at the start. This runs the <code>beforeAll()</code> function of a AbstractCustomBeforeAfter class passed in. If your first test is not a built-in assertion, you will need to call <code>TestSuite.checkStarted()</code> first.</p>"},{"location":"howto/writingtests.html#testsuite-pass-fail","title":"TestSuite Pass / Fail","text":"<p>After all tests have been run, the TestSuite has a <code>ranSuccessfully()</code> function that returns a boolean to identify if all tests ran successfully. If you want to access the results, these are in a <code>results</code> List, where the label is the test name (corrected as appropriate for uniqueness).</p>"},{"location":"references/index.html","title":"References","text":"<p>References provide technical references and descriptions for using VoltScript Testing.</p>"},{"location":"references/index.html#whats-new","title":"What's new","text":"<p>Check the latest information about VoltScript Testing.</p>"},{"location":"references/index.html#repository-structure","title":"Repository structure","text":"<ul> <li>All the required code itself is in <code>src/VoltScriptTesting.vss</code>.</li> <li>Tests are in test directory. Output are written to unit-test-reports directory.</li> <li>A starter for writing your own tests is in assets/example_code/TestBootstrap.vss.</li> </ul>"},{"location":"references/index.html#dependency-management","title":"Dependency Management","text":"<p>For using VoltScript Testing Framework via VoltScript Build Manager extension in Visual Studio Code, follow the instruction on the how-to guide.</p>"},{"location":"references/index.html#core-language-functions","title":"Core language functions","text":"<p>Lists and describes core language functions used in VoltScript Testing. </p>"},{"location":"references/index.html#api-documentation","title":"API documentation","text":"<ul> <li>VoltScript Testing Framework Class Documentation</li> </ul>"},{"location":"references/index.html#unit-test-output","title":"Unit test output","text":"<p>Note</p> <p>The sample unit test output includes errors. These are not unit tests for the unit testing framework, they are samples to show the full range of output options, including failing tests, missing assertions etc.</p> <ul> <li>Basic Tester</li> <li>Basic Tester XML output</li> <li>Custom Before/After Tester</li> <li>DateTime Tester</li> </ul>"},{"location":"references/index.html#unit-tests","title":"Unit tests","text":"<ul> <li>Basic Tester</li> <li>SampleBeforeAfterTester</li> <li>SampleCustomTester</li> <li>TestBootstrap</li> </ul>"},{"location":"references/index.html#faqs","title":"FAQs","text":"<p>List of frequently asked questions related to VoltScript Testing.  </p>"},{"location":"references/index.html#documentation-and-source-code","title":"Documentation and source code","text":"<ul> <li>HCL Volt MX Go Documentation</li> <li>VoltScript<ul> <li>Documentation</li> </ul> </li> <li>VoltScript Collections<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript JSON Converter<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Console Colors<ul> <li>Source code</li> </ul> </li> <li>VoltScript Interface Designer<ul> <li>Documentation</li> </ul> </li> <li>VoltScript VoltMX Middleware<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> <li>VoltScript Logging<ul> <li>Documentation</li> <li>Source code</li> </ul> </li> </ul>"},{"location":"references/index.html#support","title":"Support","text":"<p>To share information, ask questions, and learn about VoltScript Testing, go to the Community.</p>"},{"location":"references/CoreFunctions.html","title":"Core language functions used","text":"<p>Core Functions in <code>VoltScriptTesting.vss</code></p> <p><code>%REM</code> and <code>%END REM</code> are used throughout. <code>'</code> for a single-line comment is also used.</p> <p>When listing keywords, sub/function names where the keyword is used are in brackets. Sub/function location is not used for common functions, datatypes, or As.</p> <p>In Declarations, the following language keywords are used:</p> <ul> <li>Type</li> <li>End Type</li> <li>As</li> <li>String</li> <li>Const</li> </ul>"},{"location":"references/CoreFunctions.html#private-makedirsbaliunit-function","title":"Private makeDirsBaliUnit Function","text":"<p>This is a function to create directories in a managed way.</p> <p>Language keywords used:</p> <ul> <li>Sub</li> <li>End Sub</li> <li>As</li> <li>String</li> <li>On Error GoTo</li> <li>MkDir</li> <li>CurDir</li> <li>Exit Sub</li> <li>If...Then</li> <li>End If</li> <li>Err</li> <li>Error</li> <li>MsgBox</li> <li>Cstr</li> <li>Erl</li> <li>Resume Next</li> </ul>"},{"location":"references/CoreFunctions.html#private-formattimeforoutput-function","title":"Private FormatTimeForOutput Function","text":"<p>This is a function to format a date variable.</p> <p>Language keywords used:</p> <ul> <li>Function</li> <li>End Function</li> <li>As</li> <li>Variant</li> <li>String</li> <li>Format(Variant of Date Type, String format). String format is <code>yymmddThhnnss</code></li> </ul>"},{"location":"references/CoreFunctions.html#abstractcustombeforeafter","title":"AbstractCustomBeforeAfter","text":"<p>This is an abstract class and contains no code.</p> <p>Language keywords used:</p> <ul> <li>Class</li> <li>End Class</li> <li>Sub</li> <li>End Sub</li> </ul>"},{"location":"references/CoreFunctions.html#abstractcustomtester","title":"AbstractCustomTester","text":"<p>This is a basic class with minimal code.</p> <p>Language keywords used:</p> <ul> <li>Class</li> <li>End Class</li> <li>Public</li> <li>As</li> <li>Sub</li> <li>End Sub</li> <li>New</li> <li>Function</li> <li>End Function</li> <li>Set (addTestSuite)</li> <li>Me (addTestSuite)</li> <li>Boolean</li> <li>Error (runTests)</li> </ul>"},{"location":"references/CoreFunctions.html#testrunner","title":"TestRunner","text":"<p>This is the class for outputting a number of HTML files, with an index.html wrapping them.</p> <p>Language keywords used:</p> <ul> <li>Class</li> <li>End Class</li> <li>Private</li> <li>Public</li> <li>As</li> <li>List</li> <li>String</li> <li>Variant</li> <li>Sub</li> <li>End Sub</li> <li>New</li> <li>Me</li> <li>Now</li> <li>Delete</li> <li>Call</li> <li>Erase (Delete)</li> <li>Right</li> <li>FullTrim</li> <li>And</li> <li>Set</li> <li>Replace (getFilePath, printoutReport)</li> <li>Integer</li> <li>On Error GoTo (printoutReport)</li> <li>FreeFile (printoutReport)</li> <li>Open (printoutReport)</li> <li>For Output As (printoutReport)</li> <li>Forall...In (printoutReport)</li> <li>End ForAll (printoutReport)</li> <li>Dim (printoutReport)</li> <li>If...Then (printoutReport)</li> <li>ElseIf (printoutReport)</li> <li>Else (printoutReport)</li> <li>End If (printoutReport)</li> <li>Cstr (printoutReport)</li> <li>Print fileNum, String (printoutReport)</li> <li>Close (printoutReport)</li> <li>MsgBox (printoutReport)</li> <li>Error (printoutReport)</li> <li>Err (printoutReport)</li> <li>Erl (printoutReport)</li> <li>Resume (printoutReport)</li> </ul>"},{"location":"references/CoreFunctions.html#testsuite","title":"TestSuite","text":"<p>This is the class for a set of tests.</p> <p>Language keywords used:</p> <ul> <li>Class</li> <li>End Class</li> <li>Public</li> <li>As</li> <li>String</li> <li>Private</li> <li>Integer</li> <li>List</li> <li>Double</li> <li>Boolean</li> <li>Variant</li> <li>Sub</li> <li>End Sub</li> <li>New</li> <li>Me</li> <li>Function</li> <li>End Function</li> <li>Variant</li> <li>Set</li> <li>Delete</li> <li>Now (Delete, checkStarted)</li> <li>On Error GoTo (Delete)</li> <li>If...Then (Delete, checkStarted, convertErrorStack, runBeforeEach, runAfterEach, various assertions)</li> <li>Else (Delete, convertErrorStack, various assertions)</li> <li>End If (Delete, checkStarted, runBeforeEach, runAfterEach, various assertions)</li> <li>Not (Delete, checkStarted, convertErrorStack, runBeforeEach, runAfterEach, various assertions)</li> <li>Is Nothing (Delete, checkStarted, runBeforeEach, runAfterEach)</li> <li>Dim</li> <li>Format(Variant of Date Type, String format). String format is <code>yymmddThhnnss</code> (Delete)</li> <li>Now (Delete)</li> <li>Call</li> <li>Exit Sub (Delete)</li> <li>MsgBox (Delete)</li> <li>Error (Delete)</li> <li>Err (Delete)</li> <li>Erl (Delete)</li> <li>CStr</li> <li>Resume (Delete, assertEqualsPrimitive)</li> <li>While (makeDescriptionUnique)</li> <li>Wend (makeDescriptionUnique)</li> <li>IsElement (makeDescriptionUnique)</li> <li>True (checkStarted, various assertions)</li> <li>* (checkStarted)</li> <li>- (checkStarted)</li> <li>Right</li> <li>FullTrim</li> <li>And</li> <li>Round (duration)</li> <li>IsArray (convertErrorStack, assertNotEqualPrimitiveOrPrimitiveArray, testArrays)</li> <li>For...To (convertErrorStack, processArray, assertNotEqualPrimitiveOrPrimitiveArray)</li> <li>Next (convertErrorStack, processArray, assertNotEqualPrimitiveOrPrimitiveArray)</li> <li>UBound (convertErrorStack, processArray, assertNotEqualPrimitiveOrPrimitiveArray, testArrays)</li> <li>False (various assertions)</li> <li>= (various assertions)</li> <li>&lt;&gt; (various assertions)</li> <li>LCase (assertEqualsString, assertIs, assertIsNot)</li> <li>Long (assertEqualsLong, assertNotEqualLong)</li> <li>Single (assertEqualsSingle, assertNotEqualSingle)</li> <li>IsNumeric (assertEqualsNumeric, assertNotEqualNumeric)</li> <li>CDbl (assertEqualsNumeric, assertNotEqualNumeric, assertEqualsPrimitive)</li> <li>TypeName (assertIs, assertIsNot, assertEqualsPrimitive, assertNotEqualPrimitiveOrPrimitiveArray)</li> <li>On Error ErrNum GoTo (assertEqualsPrimitive)</li> <li>Select (assertEqualsPrimitive)</li> <li>End Select (assertEqualsPrimitive)</li> <li>CBool (assertEqualsPrimitive)</li> <li>CInt (assertEqualsPrimitive)</li> <li>CLng (assertEqualsPrimitive)</li> <li>CSng (assertEqualsPrimitive)</li> <li>Exit Function (assertEqualsPrimitive)</li> <li>ReDim Preserve (processArray)</li> <li>Join (processArray, assertNotEqualPrimitiveOrPrimitiveArray, testArrays)</li> <li>FullTrim (addResult, addError)</li> <li>Try / Catch / Finally (specific to VoltScript)</li> <li>GetThreadInfo(12) (specific to VoltScript)</li> </ul>"},{"location":"references/CoreFunctions.html#testsuitereport","title":"TestSuiteReport","text":"<p>This is the class for writing out an HTML file for a TestSuite.</p> <p>Language keywords used:</p> <ul> <li>Class</li> <li>End Class</li> <li>Private</li> <li>As</li> <li>String</li> <li>Sub</li> <li>End Sub</li> <li>New</li> <li>If...Then (New, printoutReport)</li> <li>Else (New)</li> <li>End If (New, printoutReport)</li> <li>Me</li> <li>Dim (printoutReport)</li> <li>String arrays (printoutReport)</li> <li>Integer</li> <li>On Error GoTo (printoutReport)</li> <li>Forall...In (printoutReport)</li> <li>End ForAll (printoutReport)</li> <li>CStr (printoutReport)</li> <li>FreeFile (printoutReport)</li> <li>Call</li> <li>Replace (printoutReport)</li> <li>Open (printoutReport)</li> <li>For Output As (printoutReport)</li> <li>Print (printoutReport)</li> <li>Close (printoutReport)</li> <li>Exit Sub</li> <li>MsgBox (printoutReport)</li> <li>Error (printoutReport)</li> <li>Err (printoutReport)</li> <li>Erl (printoutReport)</li> <li>Resume (printoutReport)</li> </ul>"},{"location":"references/FAQs.html","title":"FAQs","text":""},{"location":"references/FAQs.html#where-do-i-find-the-output","title":"Where do I find the output?","text":"<p>The output, by default, is in a <code>unit-test-reports</code> directory defined by the <code>BASE_REPORT_LOC</code> constant in <code>TestRunner.vss</code>. The directory is under the directory of the program running the tests.</p>"},{"location":"references/FAQs.html#how-do-i-change-the-output-directory","title":"How do I change the output directory?","text":"<p>If you wish to change the output directory for every test runner using the script, change the <code>BASE_REPORT_LOC</code> constant.</p> <p>If you wish to change the output directory for a single set of tests:</p> <ul> <li>If using a TestRunner, call <code>TestRunner.outputTo()</code>.</li> <li>If just using a TestSuite independent of a test runner, call <code>TestSuite.outputTo()</code>.</li> </ul>"},{"location":"references/FAQs.html#i-set-outputto-for-a-testsuite-but-why-is-it-not-working","title":"I set <code>outputTo</code> for a TestSuite, but why is it not working?","text":"<p>Make sure that the test suite has been added to a TestRunner so that the location for the TestRunner overrides any setting in the test suite. Otherwise, the <code>index.html</code> won't map to the test suite's output.</p>"},{"location":"references/FAQs.html#im-using-a-testrunner-but-why-is-the-testsuites-output-not-in-the-testrunners-subdirectory","title":"I'm using a TestRunner, but why is the TestSuite's output not in the TestRunner's subdirectory?","text":"<p>The usual cause is omitting to call <code>TestRunner.addTestSuite()</code>.</p>"},{"location":"references/FAQs.html#what-are-missing-assertions","title":"What are missing assertions?","text":"<p>This means you have called <code>describe()</code> but a corresponding assertion - or call to <code>addResult()</code> or <code>addError()</code> - has not been included. This could be because other code after the <code>describe()</code> call has generated an error and needs fixing.</p>"},{"location":"references/FAQs.html#i-am-using-a-custombeforeafter-but-why-is-the-assertion-not-taking-into-account-the-value-from-the-beforeeach","title":"I am using a <code>CustomBeforeAfter</code>, but why is the assertion not taking into account the value from the <code>beforeEach()</code>?","text":"<p>Make sure your code isn't running a function that modifies a value being modified in the <code>beforeEach</code>, such as <code>assertEqualsDouble(f, CDbl(a))</code>, where <code>a</code> is incremented in the <code>beforeEach()</code>. In the above line, the order of processing would be:</p> <ol> <li>CDbl(a)</li> <li>Call to assertion.</li> <li>Run <code>beforeEach()</code>, incrementing <code>a</code>.</li> <li>Run assertion.</li> </ol> <p>If <code>beforeEach()</code> is a pure function, that is it just instantiates dummy data and doesn't modify any global variables, you could manually call <code>beforeEach()</code> before modifying the value that you are passing into the assertion. Alternatively, just compare against the value before the <code>beforeEach()</code> has run.</p>"},{"location":"references/FAQs.html#whats-the-recommended-best-practice-for-test-suites","title":"What's the recommended best practice for test suites?","text":"<p>Creating a separate function for each TestSuite gives the greatest clarity. It also allows aborting a run if a key TestSuite fails. Each TestSuite is usually designed to test a specific process or self-contained aspect of the code or application.</p> <p>TestSuites for unit tests and integration tests are typically also separated. Unit tests are used to test functions that don't depend on specific environmental aspects, such as specific users and specific data. In other technologies, unit tests include mocking.</p> <p>Integration tests are used to test code that requires specific data to be available, specific user access to be in place, real-world testing of external systems.</p>"},{"location":"references/FAQs.html#how-can-we-mock-data-or-users","title":"How can we mock data or users?","text":"<p>Before/After code can create data specifically for testing. These would then become integration tests.</p> <p>Java has Mockito framework because sub-classing is always possible and API calls can be intercepted. That's not an option here. TestSuite functions are best written in the same file as the functions being tested. The same approach is used for Rust and has the added benefit of documenting how the functions are intended to be used.</p> <p>If non-LSX custom classes are used as parameters, this may allow sub-classing with a mocked object to test a complete function. More commonly, branching logic needs to be added to the functions to route differently if the callee is a test. If the tests are in the same file as the functions being called, private variables can be used to determine if a test is being run or determine if an error should be thrown.</p>"},{"location":"references/FAQs.html#does-testing-means-i-have-to-write-my-functions-differently","title":"Does testing means I have to write my functions differently","text":"<p>Yes, it probably will. Writing code is one thing, writing testable code is a completely different beast, and not specific to any one language. It's not hard to find articles written about this.</p>"},{"location":"references/whatsnew.html","title":"What's new","text":"<p>The section provides information on the latest features, improvements, and resolved issues related to VoltScript Testing.</p> v1.0.1 - What's new or changed v1.0.0 - What's new or changed"},{"location":"references/whatsnew.html#v101","title":"v1.0.1","text":"<p>Improvements</p> <ul> <li>Updated API doc from VoltScript Interface Designer.</li> <li>Code merged with skeletons auto-generated from VoltScript Interface Designer.</li> </ul>"},{"location":"references/whatsnew.html#v100","title":"v1.0.0","text":"<ul> <li>First release version of VoltScript Testing.</li> </ul>"},{"location":"topicguides/index.html","title":"Topic guides","text":"<p>Topic guides discuss and explain topics and concepts about VoltScript Testing.</p> <ul> <li>Aims for VoltScript Testing</li> <li>Challenges</li> </ul>"},{"location":"topicguides/aims.html","title":"Aims for VoltScript Testing","text":"<ul> <li>Make it easy to write terse, clear, readable tests.</li> <li>Support unit testing and integration testing.</li> <li>Minimize regression bugs.</li> <li>Generate project documentation.</li> <li>Integrate with CI/CD processes.</li> <li>Provide the most commonly used assertions, but not overwhelm with variations.</li> <li>Provide flexibility for standing up and tearing down data around tests.</li> <li>Provide intuitive coding structures.</li> <li>Provide a pleasurable coding experience.</li> </ul>"},{"location":"topicguides/approach.html","title":"Challenges","text":""},{"location":"topicguides/approach.html#beforeafter-functions-no-lambdas","title":"Before/After functions: No lambdas","text":"<p>VoltScript does not have the concept of anonymous functions or lambdas. So code cannot be passed to a <code>beforeAll()</code> function. But developers will need to run code before / after individual tests or all tests.</p> <p>So how do we enable this?</p> <p>The approach was one used for a previous HCL open source project, Volt MX LotusScript Toolkit, and used in other VoltScript projects: to use an abstract class which specific functions that should be overridden.</p> <p>The <code>AbstractCustomBeforeAfter</code> class provides the template for this. Rather than modify this class in the <code>VoltScriptTesting.vss</code> module every time, developers are expected to create a derived class that extends <code>AbstractCustomBeforeAfter</code>. Then override the relevant functions. In the test code, create an instance of the class and pass it to the TestSuite. The TestSuite can then call the functions.</p>"},{"location":"topicguides/approach.html#mocking-code","title":"Mocking Code","text":"<p>VoltScript Extension classes and core functions cannot be extended. So whereas other languages can create a mock class, that cannot be done in VoltScript. And it's not possible to re-route the language functions to alternate code during a test run.</p> <p>The approach is one similar to the Rust language, namely to include tests in the same VoltScript library module (.vss). This allows you to use private variable (such as FORCE_ERROR, RUN_TESTS) to identify if tests are running or if you want to force an error, and put specific code in your functions accordingly.</p> <p>You may also need to change the way your functions are written so objects are passed in. That allows a unit or integration test to create those objects outside of the function, and test the result based upon different objects.</p>"},{"location":"topicguides/approach.html#identifying-tests","title":"Identifying Tests","text":"<p>VoltScript cannot use annotations, so there's not a way to identify unit or integration test functions in a way that the VoltScript runtime can automatically identify. The idiom is to add your tests at the end of the VoltScript library module.</p>"},{"location":"tutorials/index.html","title":"Tutorials","text":"<p>Tutorials give hands-on introduction on how to use VoltScript Testing.</p> <ul> <li>Create a TestRunner</li> </ul>"},{"location":"tutorials/1-simple.html","title":"Create a TestRunner","text":"<p>The tutorial guides you in creating a TestRunner with two TestSuites and outputs HTML reports.</p>"},{"location":"tutorials/1-simple.html#to-create-a-testrunner","title":"To create a TestRunner","text":"<ol> <li> <p>Add the <code>VoltScriptTesting.vss</code> script to your project directory - the recommended method is to use dependency management. </p> <p>Tip</p> <p>The best practice structure for the project directory is the <code>src</code> directory for main runnable scripts, <code>libs</code> directory for VoltScript dependencies, and <code>test</code> for unit and integration test runnable scripts. In this structure, <code>VoltScripttesting.vss</code> would go into <code>libs</code>.</p> </li> <li> <p>Create a .vss script file in <code>test</code>.</p> </li> <li> <p>Add <code>Use \"../libs/VoltScriptTesting\"</code> at the top. This navigates up a directory, across to the <code>libs</code> directory and down to the <code>VoltScriptTesting.vss</code> within it. Your <code>Use</code> statement shouldn't include the .vss suffix.</p> <p>Tip</p> <p>Best practice options settings to add are <code>Option Declare</code>. You can also add <code>Option Public</code> to make all methods and classes public by default.</p> </li> <li> <p>Add a <code>Sub Initialize</code> and its closing <code>End Sub</code> statement.</p> </li> <li> <p>Add the following code within the <code>Sub Initialize</code>:</p> <pre><code>Dim testRunner As New TestRunner(\"Sample Tests\")\nDim testSuite1 As New TestSuite(\"Test Suite 1\")\nDim testSuite2 As New TestSuite(\"Test Suite 2\")\nDim x as Integer\n\nCall testRunner.addTestSuite(testSuite1)\nCall testSuite1.describe(\"Test x = False\").assertFalse(x)\nx = -1\nCall testSuite1.describe(\"Test x = True\").assertTrue(x)\n\nCall testRunner.addTestSuite(testSuite2)\nCall testSuite2.describe(\"Test x = -1\").assertEqualsInteger(-1,x)\nCall testSuite2.describe(\"Test x less than 0\").assertIsLessThan(0, x)\n</code></pre> <p>What does the code mean?</p> <p>Line 1 creates a TestRunner to hold the tests. Lines 2 and 3 create two test suites. Line 6 adds the first TestSuite to the test runner. The following lines add tests. </p> <p><code>describe()</code> is a fluent function that returns the <code>testSuite1</code> variable so you can call <code>describe()</code> and the subsequent assertion on the same line. Here, you can just use a basic boolean assertion.</p> <p>Line 11 adds the second TestSuite to the test runner. Line 12 uses an integer assertion. Line 13 asserts that <code>x</code> is less than 0.</p> <p>When using other numeric assertions and literal values, you may need to use the relevant conversion function such as <code>CLng()</code>. When using assertions that take an expected value, the order is always <code>expected</code> as the first parameter and <code>actual</code> as the second. </p> </li> <li> <p>Run the code. </p> </li> </ol>"},{"location":"tutorials/1-simple.html#expected-result","title":"Expected result","text":"<p>The test results will be generated to a unit-test-reports directory in the runtime directory. If running from the command line, this will be the current directory. If running from Visual Studio Code, it will be the directory open in VS Code.</p> <p>You can find a more thorough example in BasicTester.</p>"}]}